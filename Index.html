<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Web - Prototype v1.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #87CEEB;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 1000;
        }
        
        #info {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
            max-width: 300px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 30px 50px;
            border-radius: 10px;
            color: white;
            font-size: 24px;
            z-index: 2000;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading">Loading World...</div>
    
    <canvas id="canvas"></canvas>
    
    <div id="crosshair"></div>
    
    <div id="ui">
        <div id="info">
            <strong>ðŸŽ® Minecraft Web - Prototype v1.0</strong><br>
            <span id="fps">FPS: 0</span><br>
            Position: <span id="position">0, 0, 0</span><br>
            <br>
            <strong>Controls:</strong><br>
            WASD - Move<br>
            Mouse - Look Around<br>
            Space - Jump<br>
            Shift - Crouch<br>
            Click - Lock Pointer
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration
        const CONFIG = {
            RENDER_DISTANCE: 8,
            CHUNK_SIZE: 16,
            BLOCK_SIZE: 1,
            GRAVITY: 20,
            JUMP_FORCE: 8,
            MOVE_SPEED: 5,
            MOUSE_SENSITIVITY: 0.002
        };

        // Block Types
        const BLOCKS = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4,
            LEAVES: 5,
            WATER: 6
        };

        // Block Colors
        const BLOCK_COLORS = {
            [BLOCKS.GRASS]: 0x3a9d23,
            [BLOCKS.DIRT]: 0x8B4513,
            [BLOCKS.STONE]: 0x808080,
            [BLOCKS.WOOD]: 0x8B4513,
            [BLOCKS.LEAVES]: 0x228B22,
            [BLOCKS.WATER]: 0x1E90FF
        };

        // Game State
        class Game {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
                
                this.chunks = new Map();
                this.player = {
                    position: new THREE.Vector3(0, 50, 0),
                    velocity: new THREE.Vector3(0, 0, 0),
                    rotation: new THREE.Euler(0, 0, 0),
                    onGround: false
                };
                
                this.controls = {
                    forward: false,
                    backward: false,
                    left: false,
                    right: false,
                    jump: false,
                    crouch: false
                };
                
                this.clock = new THREE.Clock();
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                
                this.init();
            }
            
            init() {
                // Setup renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = true;
                
                // Setup camera
                this.camera.position.copy(this.player.position);
                
                // Add lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(50, 100, 50);
                dirLight.castShadow = true;
                dirLight.shadow.camera.left = -100;
                dirLight.shadow.camera.right = 100;
                dirLight.shadow.camera.top = 100;
                dirLight.shadow.camera.bottom = -100;
                this.scene.add(dirLight);
                
                // Add fog
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, CONFIG.RENDER_DISTANCE * CONFIG.CHUNK_SIZE);
                
                // Generate world
                this.generateWorld();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Hide loading screen
                document.getElementById('loading').classList.add('hidden');
                
                // Start game loop
                this.animate();
            }
            
            generateWorld() {
                const halfRender = Math.floor(CONFIG.RENDER_DISTANCE / 2);
                
                for (let x = -halfRender; x < halfRender; x++) {
                    for (let z = -halfRender; z < halfRender; z++) {
                        this.generateChunk(x, z);
                    }
                }
            }
            
            generateChunk(chunkX, chunkZ) {
                const chunk = new THREE.Group();
                const key = `${chunkX},${chunkZ}`;
                
                const geometry = new THREE.BoxGeometry(CONFIG.BLOCK_SIZE, CONFIG.BLOCK_SIZE, CONFIG.BLOCK_SIZE);
                
                for (let x = 0; x < CONFIG.CHUNK_SIZE; x++) {
                    for (let z = 0; z < CONFIG.CHUNK_SIZE; z++) {
                        const worldX = chunkX * CONFIG.CHUNK_SIZE + x;
                        const worldZ = chunkZ * CONFIG.CHUNK_SIZE + z;
                        
                        // Simple terrain generation using noise-like function
                        const height = this.getTerrainHeight(worldX, worldZ);
                        
                        for (let y = 0; y <= height; y++) {
                            let blockType;
                            
                            if (y === height && y > 8) {
                                blockType = BLOCKS.GRASS;
                            } else if (y > height - 3 && y > 8) {
                                blockType = BLOCKS.DIRT;
                            } else if (y <= 8) {
                                blockType = BLOCKS.WATER;
                            } else {
                                blockType = BLOCKS.STONE;
                            }
                            
                            // Add trees randomly
                            if (blockType === BLOCKS.GRASS && Math.random() > 0.98 && y > 10) {
                                this.generateTree(chunk, geometry, x, y + 1, z);
                            }
                            
                            const material = new THREE.MeshLambertMaterial({ 
                                color: BLOCK_COLORS[blockType],
                                transparent: blockType === BLOCKS.WATER,
                                opacity: blockType === BLOCKS.WATER ? 0.7 : 1
                            });
                            
                            const block = new THREE.Mesh(geometry, material);
                            block.position.set(x, y, z);
                            block.castShadow = true;
                            block.receiveShadow = true;
                            chunk.add(block);
                        }
                    }
                }
                
                chunk.position.set(
                    chunkX * CONFIG.CHUNK_SIZE,
                    0,
                    chunkZ * CONFIG.CHUNK_SIZE
                );
                
                this.chunks.set(key, chunk);
                this.scene.add(chunk);
            }
            
            generateTree(chunk, geometry, x, y, z) {
                // Trunk
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: BLOCK_COLORS[BLOCKS.WOOD] });
                for (let i = 0; i < 5; i++) {
                    const trunk = new THREE.Mesh(geometry, trunkMaterial);
                    trunk.position.set(x, y + i, z);
                    chunk.add(trunk);
                }
                
                // Leaves
                const leavesMaterial = new THREE.MeshLambertMaterial({ color: BLOCK_COLORS[BLOCKS.LEAVES] });
                for (let lx = -2; lx <= 2; lx++) {
                    for (let lz = -2; lz <= 2; lz++) {
                        for (let ly = 0; ly < 3; ly++) {
                            if (Math.abs(lx) === 2 && Math.abs(lz) === 2 && ly < 2) continue;
                            const leaves = new THREE.Mesh(geometry, leavesMaterial);
                            leaves.position.set(x + lx, y + 4 + ly, z + lz);
                            chunk.add(leaves);
                        }
                    }
                }
            }
            
            getTerrainHeight(x, z) {
                // Simple sine-based terrain
                const scale = 0.05;
                const height = Math.sin(x * scale) * 5 + Math.cos(z * scale) * 5 + 
                              Math.sin(x * scale * 2) * 2 + Math.cos(z * scale * 2) * 2;
                return Math.floor(height + 15);
            }
            
            setupEventListeners() {
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    switch(e.code) {
                        case 'KeyW': this.controls.forward = true; break;
                        case 'KeyS': this.controls.backward = true; break;
                        case 'KeyA': this.controls.left = true; break;
                        case 'KeyD': this.controls.right = true; break;
                        case 'Space': this.controls.jump = true; e.preventDefault(); break;
                        case 'ShiftLeft': this.controls.crouch = true; break;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    switch(e.code) {
                        case 'KeyW': this.controls.forward = false; break;
                        case 'KeyS': this.controls.backward = false; break;
                        case 'KeyA': this.controls.left = false; break;
                        case 'KeyD': this.controls.right = false; break;
                        case 'Space': this.controls.jump = false; break;
                        case 'ShiftLeft': this.controls.crouch = false; break;
                    }
                });
                
                // Mouse
                document.addEventListener('click', () => {
                    document.body.requestPointerLock();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === document.body) {
                        this.player.rotation.y -= e.movementX * CONFIG.MOUSE_SENSITIVITY;
                        this.player.rotation.x -= e.movementY * CONFIG.MOUSE_SENSITIVITY;
                        this.player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.player.rotation.x));
                    }
                });
                
                // Resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            update(delta) {
                // Movement
                const moveSpeed = CONFIG.MOVE_SPEED * delta;
                const direction = new THREE.Vector3();
                
                if (this.controls.forward) direction.z -= 1;
                if (this.controls.backward) direction.z += 1;
                if (this.controls.left) direction.x -= 1;
                if (this.controls.right) direction.x += 1;
                
                if (direction.length() > 0) {
                    direction.normalize();
                    direction.applyEuler(new THREE.Euler(0, this.player.rotation.y, 0));
                    this.player.position.x += direction.x * moveSpeed;
                    this.player.position.z += direction.z * moveSpeed;
                }
                
                // Gravity and jumping
                if (!this.player.onGround) {
                    this.player.velocity.y -= CONFIG.GRAVITY * delta;
                } else {
                    this.player.velocity.y = 0;
                    if (this.controls.jump) {
                        this.player.velocity.y = CONFIG.JUMP_FORCE;
                        this.player.onGround = false;
                    }
                }
                
                this.player.position.y += this.player.velocity.y * delta;
                
                // Simple ground collision
                const groundHeight = this.getTerrainHeight(
                    Math.floor(this.player.position.x),
                    Math.floor(this.player.position.z)
                ) + 2;
                
                if (this.player.position.y <= groundHeight) {
                    this.player.position.y = groundHeight;
                    this.player.onGround = true;
                } else {
                    this.player.onGround = false;
                }
                
                // Update camera
                this.camera.position.copy(this.player.position);
                this.camera.rotation.set(this.player.rotation.x, this.player.rotation.y, 0);
                
                // Update UI
                document.getElementById('position').textContent = 
                    `${this.player.position.x.toFixed(1)}, ${this.player.position.y.toFixed(1)}, ${this.player.position.z.toFixed(1)}`;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const delta = this.clock.getDelta();
                this.update(delta);
                this.renderer.render(this.scene, this.camera);
                
                // FPS counter
                this.frameCount++;
                const elapsed = this.clock.getElapsedTime();
                if (elapsed - this.lastFpsUpdate > 0.5) {
                    const fps = Math.round(this.frameCount / (elapsed - this.lastFpsUpdate));
                    document.getElementById('fps').textContent = `FPS: ${fps}`;
                    this.frameCount = 0;
                    this.lastFpsUpdate = elapsed;
                }
            }
        }

        // Initialize game
        const game = new Game();
    </script>
</body>
</html>




